"use strict";export class DiffEngine{schema;ignored;constructor(e){this.schema=e?.schema||{},this.ignored=e?.ignoreKeys?.map(o=>String(o))||[]}detectCircularReference(e,o){if(e&&typeof e=="object"){if(o.has(e))throw new Error("Circular reference detected");o.add(e);for(const a of Object.keys(e))this.detectCircularReference(e[a],o)}}async callDiffTracker(e,o,a){try{this.log("Initiated callDiffTracker"),this.detectCircularReference(e,new WeakSet),this.detectCircularReference(o,new WeakSet);const t=await this.checkDifference(e,o,a);return this.responseObj("SUCCESS","Successfully found difference",t)}catch(t){const n=t instanceof Error?t.message:String(t);return this.responseObj("ERROR",`Errored in callDiffTracker with message: ${n}`,null)}}async checkDifference(e,o,a={}){this.log("Initiated checkDifference");try{const t=Array.from(new Set([...Object.keys(e),...Object.keys(o)]));for(const n of t){if(this.isIgnoredKey(n))continue;const i=e[n],r=o[n];if(Array.isArray(i)&&Array.isArray(r)){const s=await this.handleArrays(i,r,n);s&&(Array.isArray(s)?s.length>0:Object.keys(s).length>0)&&(a[n]=s)}else if(i&&typeof i=="object"&&r==null)await this.handleObjectToNullChange(n,e,a);else if(i==null&&r&&typeof r=="object")await this.handleNullToObjectChange(n,o,a);else if(i&&typeof i=="object"&&r&&typeof r=="object"){const s=await this.checkDifference(i,r,{});this.log("*********** CHECK DIFFERENCE CALLED ************"),Object.keys(s).length&&(a[n]=s)}else!i&&r?a[n]={mannerOfChange:"ADDITION",initialValue:"-",latestValue:r}:!r&&i?a[n]={mannerOfChange:"DELETION",initialValue:i,latestValue:"-"}:i?.toString().trim()!==r?.toString().trim()&&(a[n]={mannerOfChange:"MODIFICATION",initialValue:i,latestValue:r})}return a}catch(t){const n=t instanceof Error?t.message:String(t);throw new Error(n)}}async handleArrays(e,o,a){if(this.log(`handleArrays for ${a}`),typeof e?.[0]=="object"&&typeof o?.[0]=="object"){const t=this.schema[a]?.arrayItemIdentifier;if(!t)throw new Error("Please provide the unique identifier to detect the changes in the array");return await this.getArrayOfObjectDiff(e,o,t)}else{const t=e.map(s=>this.normalizeString(s?.toString()))??[],n=o.map(s=>this.normalizeString(s?.toString()))??[],i=t.filter(s=>!n.includes(s)).map(s=>({mannerOfChange:"DELETION",initialValue:s,latestValue:"-"}));return[...n.filter(s=>!t.includes(s)).map(s=>({mannerOfChange:"ADDITION",initialValue:"-",latestValue:s})),...i]}}async getArrayOfObjectDiff(e,o,a){this.log("Initiated getArrayOfObjectDiff");const t=[],n=new Map(e.map(r=>[r[a],r])),i=new Map(o.map(r=>[r[a],r]));for(const[r,s]of i)if(!n.has(r))t.push({arrayItemIdentifier:r,mannerOfChange:"ADDITION",latestValue:s});else{const c=n.get(r),l=await this.checkDifference(c,s);Object.keys(l).length&&t.push({arrayItemIdentifier:r,difference:l})}for(const[r,s]of n)i.has(r)||t.push({arrayItemIdentifier:r,mannerOfChange:"DELETION",initialValue:s});return t}async handleObjectToNullChange(e,o,a){this.log("Initiated handleObjectToNullChange");const t=o[e],n={};for(const i of Object.keys(t)){if(t[i]&&typeof t[i]=="object")return await this.handleObjectToNullChange(i,t,n),a[e]=n,a;t[i]&&(n[i]={mannerOfChange:"DELETION",initialValue:t[i],latestValue:"-"})}return Object.keys(n).length&&(a[e]=n),a}async handleNullToObjectChange(e,o,a){this.log(`Initiated handleNullToObjectChange: ${e}`);const t=o[e]||{},n={};for(const i of Object.keys(t)){if(t[i]&&typeof t[i]=="object")return await this.handleNullToObjectChange(i,t,n),a[e]=n,a;t[i]&&(n[i]={mannerOfChange:"ADDITION",initialValue:"-",latestValue:t[i]})}return Object.keys(n).length&&(a[e]=n),a}isIgnoredKey(e){return this.ignored.includes(e)}normalizeString(e){return e.replace(/\s+/g,"").trim()}log(e){console.log(`${e}`)}responseObj(e,o,a){return{status:e,message:o,data:a}}}
